{
  "task_description": "# PRD: Better Auth Implementation\n\n## Projektkontext\nKleines Kosmetikstudio – Admin-Bereich für Kundenverwaltung und DSGVO-Unterschriften. **Nur ein einziger User** (die Inhaberin) soll Zugang haben. Keine öffentliche Registrierung.\n\n---\n\n## Tech Stack\n- **Framework:** Next.js 15+ (App Router)\n- **Database:** Neon Postgres\n- **ORM:** Drizzle\n- **Auth:** Better Auth\n- **Forms:** React Hook Form + Zod\n- **Data Fetching:** React Query (TanStack Query) – wo nötig\n\n---\n\n## Anforderungen\n\n### 1. Auth-Methode\n- **Email + Password** – nur diese Methode, keine Social Logins\n- Kein \"Passwort vergessen\" Flow nötig (kann manuell in DB geändert werden)\n\n### 2. Registrierung\n- **Öffentliche Registrierung deaktivieren** via `disabledPaths`\n- Admin-User wird einmalig per Seed-Script angelegt\n\n### 3. Session\n- Standard Session-basiert (kein JWT)\n- Session Dauer: 30 Tage (`expiresIn: 60 * 60 * 24 * 30`)\n- `updateAge`: 24 Stunden (Session wird nur 1x pro Tag verlängert)\n\n### 4. Geschützte Routen\n- Alles unter `/office/*` muss authentifiziert sein\n- Middleware prüft Session Cookie, redirect zu `/login` wenn nicht eingeloggt\n\n### 5. Kein Email-Versand\n- Keine Email-Verifizierung\n- Keine Passwort-Reset-Emails\n- Alles lokal/manuell\n\n---\n\n## Entscheidungen (für den Agent)\n\n| Frage | Antwort |\n|-------|---------|\n| Social Login (Google, etc.)? | **Nein** |\n| Email Verifizierung? | **Nein** |\n| Passwort Reset per Email? | **Nein** |\n| Öffentliche Registrierung? | **Nein** – `disabledPaths: [\"/sign-up/email\"]` |\n| Mehrere User? | **Nein** – nur 1 Admin |\n| 2FA? | **Nein** |\n| Admin Plugin? | **Nein** – nicht nötig bei Single-User |\n| Rate Limiting? | **Ja** – Standard-Defaults |\n\n---\n\n## Implementierung\n\n### Datei: `lib/auth.ts`\n\n```ts\nimport { betterAuth } from \"better-auth\";\nimport { drizzleAdapter } from \"better-auth/adapters/drizzle\";\nimport { db } from \"@/db\";\nimport * as schema from \"@/db/schema\";\n\nexport const auth = betterAuth({\n  database: drizzleAdapter(db, {\n    provider: \"pg\",\n    schema,\n  }),\n  \n  emailAndPassword: {\n    enabled: true,\n    minPasswordLength: 8,\n    maxPasswordLength: 128,\n    autoSignIn: true, // Nach Login automatisch Session erstellen\n  },\n  \n  // Sign-Up Endpoint deaktivieren (kein öffentliches Registrieren)\n  disabledPaths: [\"/sign-up/email\"],\n  \n  session: {\n    expiresIn: 60 * 60 * 24 * 30, // 30 Tage\n    updateAge: 60 * 60 * 24, // Session-Expiry wird 1x pro Tag aktualisiert\n  },\n  \n  // Trusted Origins für CORS\n  trustedOrigins: [\n    process.env.NEXT_PUBLIC_APP_URL || \"http://localhost:3000\",\n  ],\n});\n\nexport type Session = typeof auth.$Infer.Session;\n```\n\n### Datei: `lib/auth-client.ts`\n\n```ts\nimport { createAuthClient } from \"better-auth/react\";\n\nexport const authClient = createAuthClient({\n  baseURL: process.env.NEXT_PUBLIC_APP_URL || \"\",\n});\n\nexport const { signIn, signOut, useSession } = authClient;\n```\n\n### Datei: `app/api/auth/[...all]/route.ts`\n\n```ts\nimport { auth } from \"@/lib/auth\";\nimport { toNextJsHandler } from \"better-auth/next-js\";\n\nexport const { GET, POST } = toNextJsHandler(auth);\n```\n\n### Datei: `proxy.ts` (ehemals middleware.ts)\n\n> **Wichtig:** In Next.js 16 wurde `middleware.ts` zu `proxy.ts` umbenannt und die Funktion heißt jetzt `proxy` statt `middleware`.\n\n```ts\nimport { NextRequest, NextResponse } from \"next/server\";\nimport { auth } from \"@/lib/auth\";\n\nexport async function proxy(request: NextRequest) {\n  const session = await auth.api.getSession({\n    headers: request.headers,\n  });\n\n  const { pathname } = request.nextUrl;\n\n  // Login-Seite: Redirect wenn schon eingeloggt\n  if (session && pathname === \"/login\") {\n    return NextResponse.redirect(new URL(\"/office\", request.url));\n  }\n\n  // Geschützte Office-Routen: Redirect wenn nicht eingeloggt\n  if (!session && pathname.startsWith(\"/office\")) {\n    return NextResponse.redirect(new URL(\"/login\", request.url));\n  }\n\n  return NextResponse.next();\n}\n\nexport const config = {\n  matcher: [\"/office/:path*\", \"/login\"],\n};\n```\n\n---\n\n## Drizzle Schema (wird von Better Auth CLI generiert)\n\nNach Setup ausführen:\n```bash\nnpx @better-auth/cli generate --output ./db/auth-schema.ts\n```\n\nDann in `db/schema.ts` importieren und exportieren:\n```ts\nexport * from \"./auth-schema\";\n// ... rest of your schema (customers, gdprVersions, etc.)\n```\n\n---\n\n## Seed Script für Admin-User\n\nDatei: `scripts/seed-admin.ts`\n\n```ts\nimport { db } from \"@/db\";\nimport { user, account } from \"@/db/schema\";\nimport { hash } from \"better-auth/crypto\";\n\nasync function seedAdmin() {\n  const email = process.env.ADMIN_EMAIL!;\n  const password = process.env.ADMIN_PASSWORD!;\n  const name = process.env.ADMIN_NAME || \"Admin\";\n\n  // Passwort hashen\n  const hashedPassword = await hash.hash(password);\n\n  // User erstellen\n  const [newUser] = await db\n    .insert(user)\n    .values({\n      id: crypto.randomUUID(),\n      email,\n      name,\n      emailVerified: true,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    })\n    .returning();\n\n  // Credential Account erstellen\n  await db.insert(account).values({\n    id: crypto.randomUUID(),\n    userId: newUser.id,\n    accountId: newUser.id,\n    providerId: \"credential\",\n    password: hashedPassword,\n    createdAt: new Date(),\n    updatedAt: new Date(),\n  });\n\n  console.log(\"✅ Admin user created:\", email);\n}\n\nseedAdmin().catch(console.error);\n```\n\nAusführen mit:\n```bash\nnpx tsx scripts/seed-admin.ts\n```\n\n---\n\n## Umgebungsvariablen\n\n```env\n# Database\nDATABASE_URL=postgresql://...@neon.tech/...\n\n# Auth\nBETTER_AUTH_SECRET=<generieren mit: openssl rand -base64 32>\nNEXT_PUBLIC_APP_URL=http://localhost:3000\n\n# Admin Seed (nur für initiales Setup, danach entfernen)\nADMIN_EMAIL=deine-frau@email.de\nADMIN_PASSWORD=sicheres-passwort-hier\nADMIN_NAME=StudioName\n```\n\n---\n\n## Login Page UI\n\nEinfache Login-Seite mit:\n- Email Input\n- Password Input  \n- Submit Button\n- Error State für falsche Credentials\n- Loading State während Login\n\n**Keine:**\n- \"Registrieren\" Link\n- \"Passwort vergessen\" Link\n- Social Login Buttons\n\n### Beispiel Login Component (mit React Hook Form):\n\n```tsx\n\"use client\";\n\nimport { useForm } from \"react-hook-form\";\nimport { zodResolver } from \"@hookform/resolvers/zod\";\nimport { z } from \"zod\";\nimport { useRouter } from \"next/navigation\";\nimport { useState } from \"react\";\nimport { authClient } from \"@/lib/auth-client\";\n\nconst loginSchema = z.object({\n  email: z.string().email(\"Ungültige E-Mail\"),\n  password: z.string().min(8, \"Mindestens 8 Zeichen\"),\n});\n\ntype LoginForm = z.infer<typeof loginSchema>;\n\nexport function LoginForm() {\n  const [error, setError] = useState(\"\");\n  const router = useRouter();\n\n  const {\n    register,\n    handleSubmit,\n    formState: { errors, isSubmitting },\n  } = useForm<LoginForm>({\n    resolver: zodResolver(loginSchema),\n  });\n\n  const onSubmit = async (data: LoginForm) => {\n    setError(\"\");\n\n    const { error } = await authClient.signIn.email({\n      email: data.email,\n      password: data.password,\n      callbackURL: \"/office\",\n    });\n\n    if (error) {\n      setError(\"Ungültige Anmeldedaten\");\n    } else {\n      router.push(\"/office\");\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit(onSubmit)}>\n      <div>\n        <input\n          type=\"email\"\n          {...register(\"email\")}\n          placeholder=\"E-Mail\"\n        />\n        {errors.email && <p className=\"text-red-500\">{errors.email.message}</p>}\n      </div>\n      \n      <div>\n        <input\n          type=\"password\"\n          {...register(\"password\")}\n          placeholder=\"Passwort\"\n        />\n        {errors.password && <p className=\"text-red-500\">{errors.password.message}</p>}\n      </div>\n      \n      {error && <p className=\"text-red-500\">{error}</p>}\n      \n      <button type=\"submit\" disabled={isSubmitting}>\n        {isSubmitting ? \"Lädt...\" : \"Anmelden\"}\n      </button>\n    </form>\n  );\n}\n```\n\n---\n\n## Session Check auf Protected Pages\n\nZusätzlich zur Middleware: Session auf jeder Office-Page validieren:\n\n```tsx\n// app/office/page.tsx\nimport { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\nimport { redirect } from \"next/navigation\";\n\nexport default async function OfficePage() {\n  const session = await auth.api.getSession({\n    headers: await headers(),\n  });\n\n  if (!session) {\n    redirect(\"/login\");\n  }\n\n  return (\n    <div>\n      <h1>Willkommen, {session.user.name}!</h1>\n      {/* Office Content */}\n    </div>\n  );\n}\n```\n\n---\n\n## Zusammenfassung für Agent\n\n### Dependencies installieren:\n```bash\npnpm add better-auth react-hook-form @hookform/resolvers zod @tanstack/react-query\n```\n\n### Setup-Schritte:\n1. **Auth Config:** `lib/auth.ts` mit `disabledPaths: [\"/sign-up/email\"]`\n2. **Client:** `lib/auth-client.ts` mit `createAuthClient`\n3. **API Route:** `app/api/auth/[...all]/route.ts` mit `toNextJsHandler`\n4. **Proxy:** `proxy.ts` (nicht middleware.ts!) für Auth-Redirects\n5. **Schema generieren:** `npx @better-auth/cli generate --output ./db/auth-schema.ts`\n6. **Schema exportieren:** In `db/schema.ts` das auth-schema exportieren\n7. **Seed Admin:** Einmalig `scripts/seed-admin.ts` ausführen\n8. **Login Page:** React Hook Form + Zod mit `authClient.signIn.email`\n9. **Protected Pages:** Server-side Session Check mit `auth.api.getSession`",
  "workflow_type": "feature"
}